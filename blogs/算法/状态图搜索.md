# 状态图搜索

## 状态空间方法

> 基于解答空间的问题表示和求解方法，以状态和算符为基础来表示和求解问题

### 状态

> 表示问题求解过程中每一步问题状况的数据结构

### 算符

> 当对一个问题状态使用某个可用操作时，它将引起该状态中某些分量值的变化，从而使问题从一个具体状态变为另一个具体状态

### 状态空间

> 用来描述一个问题的全部状态以及这些状态之间的相互关系

## 状态图搜索

* 搜索过程
* Close表
* OPEN表

### 盲目搜索

> 按照预定的控制策略进行搜索，在搜索过程中获得的中间信息不用来改进控制策略

#### 宽度优先搜索

> 先拓展的节点先搜索

* 首先拓展初始结点
* 接着拓展初始结点的所有后继节点
* 再扩展后继节点的后继
* 在第n层节点没有全部搜索完之前，不进入第n+1层节点搜索

#### 深度优先搜索

> 新拓展的节点先搜索

### 启发式搜索

> 启发式信息是指那种与具体问题求解过程有关的，并可指导搜索过程朝着最有希望方向前进的控制信息

#### A算法

评估函数$f(n)$:估算节点“希望”程度的量度

$f(n)=g(n)+h(n)$

$g(n)$:从初始状态到当前状态的代价

$h(n)$:从当前状态到目标状态的估计代价

##### 局部择优

* 把初始节点$S_0$放入$OPEN$表，计算$f(S_0)$
* 如果$OPEN$表为空，则问题无解，退出。
* 把$OPEN$表的第一个节点取出，放入$CLOSE$表
* 考查节点$n$是否为目标节点，若是，则求得了问题的解，退出
* 若节点$n$不可扩展，则转第2步
* 扩展节点$n$用估价函数$f(x)$计算每个子节点的估价值，并按估价值的从小到大的顺序依次放入$OPEN$表的首部，并为每一个子节点都配置指向父节点的指针，转第2步

##### 有序搜索



#### A*算法

> 1968年

$f(n)=g(n)+h(n)$

$g(n)$大于0

$h(n)$满足一定条件

